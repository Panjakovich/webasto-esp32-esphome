substitutions:
  # Пины силовых цепей
  pin_glow_plug: GPIO14        # Свеча накала (PWM)
  pin_fan: GPIO27              # Вентилятор (PWM)
  pin_fuel_pump: GPIO26        # Топливный насос
  pin_water_pump: GPIO25       # Водяная помпа (PWM)
  pin_ntc_sensor: GPIO34       # Датчик температуры Webasto (ADC)
  pin_flame_sensor: GPIO35     # Датчик пламени/тока (ADC)
  pin_dallas: GPIO33           # Шина DS18B20
  pin_bypass: GPIO23           # Клапан байпаса (on/off)

  # Пороговые значения
  overheat_temp_c: "92.0"          # Перегрев Webasto (NTC)
  ignition_timeout_ms: "180000"    # Таймаут розжига (3 мин)
  min_temp_rise_c: "2.0"           # Мин. рост температуры за таймаут

  flame_loss_threshold_v: "2.2"    # Потеря пламени по току
  flame_present_threshold_v: "1.7" # Порог "появилось пламя"

  max_ignite_fail: "3"             # Макс. число неудачных запусков

  # Цель по радиаторной подаче
  radiator_target_c: "50.0"        # Желательная температура подачи на батареи
  radiator_low_c: "45.0"
  radiator_high_c: "55.0"

esphome:
  name: webasto-esp32
  friendly_name: Webasto ESP32 Controller

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

api:
  encryption:
    key: !secret webasto_api_key
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: !secret webasto_ota_password

safe_mode:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "webasto-esp32-setup"
    password: "12345678"
    ap_timeout: 5s

web_server:
  local: true

logger:
  level: DEBUG

# --- Глобальные переменные ---
globals:
  - id: heater_state
    type: int
    initial_value: '0'   # 0:OFF, 1:PREHEAT, 2:IGNITION, 3:RUNNING, 4:COOLING, 5:ERROR
  - id: fuel_freq
    type: float
    initial_value: '1.2'
  - id: fan_speed
    type: float
    initial_value: '0.3'
  - id: ignite_fail_count
    type: int
    initial_value: '0'
  - id: temp_at_start
    type: float
    initial_value: '0.0'
  - id: ignition_start_time
    type: uint32
    initial_value: '0'
  - id: bench_mode
    type: bool
    initial_value: 'false'
  - id: low_power_start_time
    type: uint32
    initial_value: '0'
  - id: last_room_temp
    type: float
    initial_value: '0.0'
  - id: last_room_temp_time
    type: uint32
    initial_value: '0'

# --- Выходы ---
output:
  - platform: ledc
    pin: ${pin_glow_plug}
    id: glow_plug_pwm
    frequency: 500Hz

  - platform: ledc
    pin: ${pin_fan}
    id: fan_pwm
    frequency: 20000Hz

  - platform: gpio
    pin: ${pin_fuel_pump}
    id: fuel_pump_output

  - platform: ledc
    pin: ${pin_water_pump}
    id: coolant_pump_pwm
    frequency: 500Hz

# --- Переключатели ---
switch:
  # Главный выключатель Webasto (HA)
  - platform: template
    name: "Webasto Master Switch"
    id: heater_switch
    icon: "mdi:fire"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

    turn_on_action:
      - if:
          condition:
            lambda: |-
              if (id(heater_state) == 5) return false;
              if (id(ignite_fail_count) >= ${max_ignite_fail}) return false;
              return true;
          then:
            - script.execute: start_sequence
          else:
            - logger.log:
                level: ERROR
                format: "START BLOCKED: error state or too many failed ignitions"
            - switch.turn_off: heater_switch

    turn_off_action:
      - script.execute: stop_sequence

  # Bench Mode для стендовых тестов
  - platform: template
    name: "Webasto Bench Mode"
    id: bench_mode_switch
    icon: "mdi:tools"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: 'id(bench_mode) = true;'
      - logger.log: "Bench mode ENABLED (temperature safety relaxed for tests)."
    turn_off_action:
      - lambda: 'id(bench_mode) = false;'
      - logger.log: "Bench mode DISABLED (temperature safety active)."

  # Сброс ошибки и счётчика неудачных пусков
  - platform: template
    name: "Webasto Reset Error"
    id: heater_reset_switch
    icon: "mdi:restart-alert"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(heater_state) = 0;
          id(ignite_fail_count) = 0;
      - delay: 500ms
      - switch.turn_off: heater_reset_switch

  # Клапан байпаса подача↔обратка
  - platform: gpio
    name: "Bypass Valve"
    id: bypass_valve
    pin: ${pin_bypass}
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:valve"

# --- Dallas (DS18B20) ---
dallas:
  - pin: ${pin_dallas}
    update_interval: 5s
    id: dallas_bus

# --- Датчики ---
sensor:
  # NTC Webasto (через ADC)
  - platform: adc
    id: water_temp_adc
    pin: ${pin_ntc_sensor}
    attenuation: 12db
    update_interval: 1s

  - platform: template
    id: water_temp_test
    name: "Water Temperature Test"
    unit_of_measurement: "V"
    lambda: |-
      return id(water_temp_adc).state;

  - platform: template
    id: water_temp_resistance
    lambda: |-
      float v_out = id(water_temp_adc).state;
      if (v_out >= 3.25 || v_out <= 0.05) return NAN;
      return 10000.0f * (v_out / (3.3f - v_out));

  - platform: ntc
    id: water_temp
    sensor: water_temp_resistance
    calibration:
      b_constant: 3950
      reference_resistance: 10kOhm
      reference_temperature: 25°C
    name: "Water Temperature"
    on_value_range:
      - above: ${overheat_temp_c}
        then:
          - logger.log:
              level: ERROR
              format: "OVERHEAT DETECTED by NTC!"
          - script.execute: emergency_shutdown

  # Ток свечи / "пламя"
  - platform: adc
    pin: ${pin_flame_sensor}
    id: flame_current
    name: "Glow Plug Current"
    attenuation: 12db
    update_interval: 0.5s
    filters:
      - sliding_window_moving_average:
          window_size: 15
          send_every: 1

  # DS18B20 – подача к радиаторам
  - platform: dallas
    address: 0x0102030405060708   # ЗАМЕНИТЬ на реальный адрес
    name: "Flow Temperature"
    id: flow_temp
    accuracy_decimals: 1

  # DS18B20 – обратка от радиаторов
  - platform: dallas
    address: 0x0807060504030201   # ЗАМЕНИТЬ на реальный адрес
    name: "Return Temperature"
    id: return_temp
    accuracy_decimals: 1

  # ΔT по контуру отопления
  - platform: template
    name: "Delta T Flow-Return"
    id: delta_t
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      if (std::isnan(id(flow_temp).state) || std::isnan(id(return_temp).state)) {
        return NAN;
      }
      return id(flow_temp).state - id(return_temp).state;

  # Температура в комнате (из Home Assistant)
  - platform: homeassistant
    id: room_temp
    entity_id: sensor.room_temperature_living   # ЗАМЕНИТЬ на реальное имя из HA
    internal: false
    name: "Room Temperature"

  # Уличная температура (из Home Assistant)
  - platform: homeassistant
    id: outdoor_temp
    entity_id: sensor.outdoor_temperature      # ЗАМЕНИТЬ на реальное имя из HA
    internal: false
    name: "Outdoor Temperature"

  # Текущая скорость вентилятора (в %)
  - platform: template
    name: "Current Fan Speed"
    unit_of_measurement: "%"
    update_interval: 1s
    accuracy_decimals: 1
    lambda: |-
      return id(fan_speed) * 100.0f;

  # Код состояния
  - platform: template
    name: "Heater State Code"
    icon: "mdi:state-machine"
    update_interval: 1s
    accuracy_decimals: 0
    lambda: |-
      return id(heater_state);

  # Частота насоса
  - platform: template
    name: "Fuel Frequency"
    unit_of_measurement: "Hz"
    update_interval: 1s
    lambda: |-
      if (id(heater_state) == 2 || id(heater_state) == 3) {
        return id(fuel_freq);
      } else {
        return 0.0f;
      }

  # Счётчик неудачных розжигов
  - platform: template
    name: "Ignite Fail Count"
    icon: "mdi:alert-counter"
    update_interval: 5s
    accuracy_decimals: 0
    lambda: |-
      return id(ignite_fail_count);

# --- Интервал 50мс: защита, насос, пламя, рост температуры ---
interval:
  - interval: 50ms
    then:
      - lambda: |-
          // 1. Защита по температуре Webasto (NTC)
          float t = id(water_temp).state;

          if (!id(bench_mode)) {
            if (!std::isnan(t) && t > ${overheat_temp_c}) {
              if (id(heater_state) != 0 && id(heater_state) != 4 && id(heater_state) != 5) {
                ESP_LOGE("safety", "OVERHEAT! Temp: %.1f", t);
                id(heater_switch).turn_off();
                id(heater_state) = 5;
              }
            }
          }

          // Ошибка датчика температуры во время розжига/работы
          if (std::isnan(t) && (id(heater_state) == 2 || id(heater_state) == 3)) {
            ESP_LOGE("safety", "TEMP SENSOR ERROR (NaN) during run!");
            id(heater_switch).turn_off();
            id(heater_state) = 5;
          }

          // 2. Управление щелчками топливного насоса
          static uint32_t last_pump = 0;
          static bool pump_is_on = false;

          if (id(heater_state) == 2 || id(heater_state) == 3) {
            uint32_t now = millis();
            if (id(fuel_freq) > 0.01f && now - last_pump >= (uint32_t)(1000.0f / id(fuel_freq))) {
              id(fuel_pump_output).turn_on();
              last_pump = now;
              pump_is_on = true;
            }
          }

          if (pump_is_on && (millis() - last_pump >= 50)) {
            id(fuel_pump_output).turn_off();
            pump_is_on = false;
          }

          // 3. Контроль срыва пламени в RUNNING
          if (id(heater_state) == 3) {
            static int flame_loss_ticks = 0;
            if (id(flame_current).state > ${flame_loss_threshold_v}) {
              flame_loss_ticks++;
              if (flame_loss_ticks > 20) {
                 ESP_LOGW("safety", "FLAME LOSS DETECTED!");
                 id(heater_switch).turn_off();
                 id(heater_state) = 5;
                 flame_loss_ticks = 0;
              }
            } else {
              flame_loss_ticks = 0;
            }
          }

          // 4. Контроль роста температуры Webasto за время розжига/работы
          if (id(heater_state) == 2 || id(heater_state) == 3) {
            uint32_t work_time = millis() - id(ignition_start_time);

            if (work_time > ${ignition_timeout_ms}) {
              if (!std::isnan(t) && !std::isnan(id(temp_at_start))) {
                float temp_diff = t - id(temp_at_start);
                if (temp_diff < ${min_temp_rise_c}) {
                  ESP_LOGE("safety", "IGNITION TIMEOUT: No temp rise! (Diff: %.1f°C)", temp_diff);
                  id(heater_switch).turn_off();
                  id(heater_state) = 5;
                }
              } else {
                ESP_LOGE("safety", "IGNITION TIMEOUT: temp sensor invalid!");
                id(heater_switch).turn_off();
                id(heater_state) = 5;
              }
            }
          } else {
            id(temp_at_start) = 0;
          }

  # Интервал 10с: авто-мощность, клапан байпаса и температура радиаторов
  - interval: 10s
    then:
      - lambda: |-
          float f = id(flow_temp).state;
          float r = id(return_temp).state;
          float d = id(delta_t).state;

          float room = id(room_temp).state;
          float room_target = id(room_target_temp).state;

          float rad_target = id(radiator_target_temp).state;
          float rad_low_margin = id(radiator_low_margin).state;
          float rad_high_margin = id(radiator_high_margin).state;

          float dt_low = id(delta_t_low).state;
          float dt_high = id(delta_t_high).state;

          float dt_bypass_open = id(bypass_open_dt).state;
          float dt_bypass_close = id(bypass_close_dt).state;

          float outdoor = id(outdoor_temp).state;

          // Управление имеет смысл только при работе котла
          if (id(heater_state) == 1 || id(heater_state) == 2) {
            // Преднагрев/розжиг: байпас открыт, малый контур
            id(bypass_valve).turn_on();
            return;
          }

          if (id(heater_state) != 3) {
            // Не рабочий режим -> байпас закрыт
            id(bypass_valve).turn_off();
            return;
          }

          // Проверки на NAN
          if (std::isnan(f) || std::isnan(r) || std::isnan(d) || std::isnan(room) || std::isnan(room_target)) {
            ESP_LOGW("auto_power", "Some sensors NAN, skip auto control.");
            return;
          }

          // --- 1. Ошибка по комнате и тренд (тепловая инерция) ---
          float room_error = room_target - room;  // >0 => надо греть

          uint32_t now = millis();
          float room_trend = 0.0f;  // °C/час

          if (id(last_room_temp_time) != 0 && !std::isnan(id(last_room_temp))) {
            float dt_ms = (float)(now - id(last_room_temp_time));
            if (dt_ms > 1.0f) {
              room_trend = (room - id(last_room_temp)) * 3600000.0f / dt_ms;
            }
          }
          id(last_room_temp) = room;
          id(last_room_temp_time) = now;

          // --- 2. Погодозависимая поправка ---
          float cold_bias = 0.0f;
          if (!std::isnan(outdoor)) {
            if (outdoor < -10.0f) {
              cold_bias = 1.0f;
            } else if (outdoor < 0.0f) {
              cold_bias = 0.5f;
            } else if (outdoor > 10.0f) {
              cold_bias = -0.5f;
            }
          }

          std::string cur_mode = id(target_power_select).state;
          std::string new_mode = cur_mode;

          // --- 3. Базовая логика по радиаторной подаче и ΔT (5 ступеней) ---
          float rad_low = rad_target - rad_low_margin;
          float rad_high = rad_target + rad_high_margin;

          // Высокая нагрузка -> High/Turbo
          if (f < rad_low - 5.0f || d > dt_high + 2.0f) {
            new_mode = "Turbo";
          } else if (f < rad_low || d > dt_high) {
            new_mode = "High";
          }
          // Средняя нагрузка -> Medium
          else if (f >= rad_low && f <= rad_high && d >= dt_low && d <= dt_high) {
            new_mode = "Medium";
          }
          // Малая нагрузка -> Low / Very Low
          else if (f > rad_high && d < dt_low) {
            if (f > rad_high + 5.0f) {
              new_mode = "Very Low";
            } else {
              new_mode = "Low";
            }
          } else {
            new_mode = "Low";
          }

          // --- 4. Коррекция по комнате и тренду ---
          if (room_error > 1.5f || room_trend < -0.5f) {
            // Холодно или остывает -> поднимаем ступень
            if (new_mode == "Very Low") new_mode = "Low";
            else if (new_mode == "Low") new_mode = "Medium";
            else if (new_mode == "Medium") {
              new_mode = (cold_bias > 0.5f) ? "High" : "Medium";
            } else if (new_mode == "High" && cold_bias > 0.5f) {
              new_mode = "Turbo";
            }
          } else if (room_error < 0.5f && room_trend > 0.2f) {
            // Почти догрели и продолжаем нагреваться -> экономим, опуская ступень
            if (new_mode == "Turbo") new_mode = "High";
            else if (new_mode == "High") new_mode = "Medium";
            else if (new_mode == "Medium") new_mode = "Low";
            else if (new_mode == "Low") new_mode = "Very Low";
          }

          // Погодозависимый общий сдвиг (тонкая коррекция)
          if (cold_bias > 0.5f) {
            if (new_mode == "Low") new_mode = "Medium";
            else if (new_mode == "Medium") new_mode = "High";
          } else if (cold_bias < -0.4f) {
            if (new_mode == "High") new_mode = "Medium";
            else if (new_mode == "Medium") new_mode = "Low";
          }

          // --- 5. Защита от сажи: долгое Low/Very Low -> прожиг ---
          if (cur_mode == "Low" || cur_mode == "Very Low") {
            uint32_t now2 = millis();
            if (now2 - id(low_power_start_time) > 15UL * 60UL * 1000UL) {
              ESP_LOGI("auto_power", "Long Low power -> bump to Medium for soot prevention");
              new_mode = "Medium";
              id(low_power_start_time) = now2;
            }
          }

          // --- 6. Применяем новый режим, если он изменился ---
          if (new_mode != cur_mode) {
            ESP_LOGI("auto_power", "Auto power: %s -> %s (room=%.1f/%.1f, flow=%.1f, return=%.1f, dT=%.1f, trend=%.2fC/h, outdoor=%.1f)",
                     cur_mode.c_str(), new_mode.c_str(), room, room_target, f, r, d, room_trend, outdoor);
            id(target_power_select).publish_state(new_mode);
          }

          // --- 7. Управление байпасом в RUNNING с учётом ΔT и подачи ---
          if (d < dt_bypass_open && f < rad_target + 5.0f) {
            id(bypass_valve).turn_on();
          } else if (d > dt_bypass_close || f > rad_target + 10.0f) {
            id(bypass_valve).turn_off();
          }

          // --- 8. Переход в режим idle вместо выключения свитча ---
          // Условия: комната чуть выше цели, тренд не падает, нагрузка по воде маленькая
          if (room_error < -0.5f && room_trend >= -0.1f && d < dt_low && f > rad_low) {
            if (id(heater_state) == 3) {
              ESP_LOGI("auto_power", "Room warm and stable -> going to IDLE (cooldown sequence)");
              // Запускаем штатный цикл остановки, но не трогаем мастер‑свитч
              id(heater_state) = 4;
              id(glow_plug_pwm).set_level(0.0f);
              id(fan_pwm).set_level(1.0f);
              // Дальше скрипт stop_sequence доведёт до полного останова
              id(stop_sequence).execute();
            }
          }

          // --- 9. Авто‑запуск из idle при недогреве комнаты ---
          // Если свитч включен, котёл в состоянии "выключен", а в комнате холоднее цели на 2°C+
          if (id(heater_switch).state && id(heater_state) == 0 && room_error > 2.0f) {
            ESP_LOGI("auto_power", "Room below target-2 -> auto start from IDLE");
            id(start_sequence).execute();
          }

# --- Скрипты управления ---
script:
  - id: start_sequence
    mode: restart
    then:
      - logger.log: "WEB-START: Initializing..."

      # Проверка датчика температуры перед пуском
      - lambda: |-
          if (std::isnan(id(water_temp).state) && !id(bench_mode)) {
            ESP_LOGE("start", "START ABORTED: NTC temp sensor invalid and bench_mode is OFF");
            id(heater_state) = 5;
          }

      - if:
          condition:
            lambda: 'return id(heater_state) == 5;'
          then:
            - logger.log:
                level: ERROR
                format: "WEB-START: Aborted due to ERROR state."
            - switch.turn_off: heater_switch
            - script.stop: start_sequence

      # Включаем помпу на уровне Medium по умолчанию
      - lambda: |-
          id(coolant_pump_pwm).set_level(0.8f);

      - lambda: 'id(heater_state) = 1;'

      # Мягкий старт вентилятора
      - lambda: 'id(fan_speed) = 0.3f;'
      - output.set_level:
          id: fan_pwm
          level: 0.3

      # Свеча накала
      - output.set_level:
          id: glow_plug_pwm
          level: 0.85

      - delay: 45s

      - logger.log: "WEB-START: Ignition phase..."
      - lambda: |-
          id(heater_state) = 2;
          id(temp_at_start) = id(water_temp).state;
          id(ignition_start_time) = millis();

      - delay: 10s

      # Ждём "появления пламени" по токовому датчику
      - wait_until:
          condition:
            lambda: 'return id(flame_current).state < ${flame_present_threshold_v};'
          timeout: 70s

      - if:
          condition:
            lambda: 'return id(flame_current).state < ${flame_present_threshold_v};'
          then:
            - logger.log: "WEB-START: Running mode active"
            - lambda: |-
                id(heater_state) = 3;
                id(ignite_fail_count) = 0;
            - output.set_level:
                id: glow_plug_pwm
                level: 0.0
            - lambda: |-
                id(fan_pwm).set_level(id(fan_speed));
          else:
            - logger.log:
                level: ERROR
                format: "WEB-START: Ignition Failed!"
            - lambda: 'id(ignite_fail_count)++;'
            - script.execute: stop_sequence

  - id: stop_sequence
    mode: restart
    then:
      - logger.log: "WEB-STOP: Cooling cycle..."
      - lambda: 'id(heater_state) = 4;'
      - output.set_level:
          id: glow_plug_pwm
          level: 0.0
      - output.set_level:
          id: fan_pwm
          level: 1.0
      - delay: 150s
      - output.set_level:
          id: fan_pwm
          level: 0.0
      - output.set_level:
          id: coolant_pump_pwm
          level: 0.0
      - lambda: 'id(heater_state) = 0;'
      - logger.log: "WEB-STOP: System Idle"

  - id: emergency_shutdown
    mode: restart
    then:
      - logger.log:
          level: ERROR
          format: "EMERGENCY SHUTDOWN!"
      - lambda: 'id(heater_state) = 5;'
      - output.set_level:
          id: glow_plug_pwm
          level: 0.0
      - output.set_level:
          id: fan_pwm
          level: 1.0
      - delay: 180s
      - output.set_level:
          id: fan_pwm
          level: 0.0
      - output.set_level:
          id: coolant_pump_pwm
          level: 0.0

# --- Текстовый статус ---
text_sensor:
  - platform: template
    name: "Heater Status"
    lambda: |-
      switch (id(heater_state)) {
        case 1: return {"Нагрев свечи"};
        case 2: return {"Розжиг"};
        case 3: return {"Работа"};
        case 4: return {"Охлаждение"};
        case 5: return {"ОШИБКА/ПЕРЕГРЕВ/ДАТЧИК"};
        default: return {"Выключен"};
      }

# --- Выбор мощности ---
select:
  - platform: template
    name: "Target Power"
    id: target_power_select
    options: ["Very Low", "Low", "Medium", "High", "Turbo"]
    initial_option: "Low"
    optimistic: true
    on_value:
      then:
        - lambda: |-
            // 5 уровней мощности котла
            if (x == "Very Low") {
              id(fuel_freq) = 0.8f;
              id(fan_speed) = 0.2f;
              id(low_power_start_time) = millis();
            } else if (x == "Low") {
              id(fuel_freq) = 1.4f;
              id(fan_speed) = 0.3f;
              id(low_power_start_time) = millis();
            } else if (x == "Medium") {
              id(fuel_freq) = 2.8f;
              id(fan_speed) = 0.5f;
            } else if (x == "High") {
              id(fuel_freq) = 4.0f;
              id(fan_speed) = 0.75f;
            } else if (x == "Turbo") {
              id(fuel_freq) = 5.5f;
              id(fan_speed) = 1.0f;
            }

            // Вентилятор
            if (id(heater_state) == 3) {
              id(fan_pwm).set_level(id(fan_speed));
            }

            // PWM помпы в зависимости от мощности
            float pump_level = 1.0f;
            if (x == "Very Low") {
              pump_level = 0.5f;
            } else if (x == "Low") {
              pump_level = 0.65f;
            } else if (x == "Medium") {
              pump_level = 0.8f;
            } else if (x == "High") {
              pump_level = 0.9f;
            } else { // Turbo
              pump_level = 1.0f;
            }
            id(coolant_pump_pwm).set_level(pump_level);

number:
  # Целевая температура воздуха в комнате
  - platform: template
    id: room_target_temp
    name: "Room Target Temperature"
    min_value: 16
    max_value: 26
    step: 0.5
    optimistic: true
    initial_value: 22

  # Целевая температура подачи радиаторов
  - platform: template
    id: radiator_target_temp
    name: "Radiator Target Temperature"
    min_value: 35
    max_value: 70
    step: 1
    optimistic: true
    initial_value: 50

  # Нижняя/верхняя границы комфортной подачи (около target)
  - platform: template
    id: radiator_low_margin
    name: "Radiator Low Margin"
    min_value: 2
    max_value: 15
    step: 0.5
    optimistic: true
    initial_value: 5

  - platform: template
    id: radiator_high_margin
    name: "Radiator High Margin"
    min_value: 2
    max_value: 15
    step: 0.5
    optimistic: true
    initial_value: 5

  # Порог ΔT для Low / Medium / High
  - platform: template
    id: delta_t_low
    name: "Delta T Low Threshold"
    min_value: 1
    max_value: 10
    step: 0.5
    optimistic: true
    initial_value: 3

  - platform: template
    id: delta_t_high
    name: "Delta T High Threshold"
    min_value: 3
    max_value: 20
    step: 0.5
    optimistic: true
    initial_value: 8

  # Пороги ΔT для управления байпасом
  - platform: template
    id: bypass_open_dt
    name: "Bypass Open Delta T"
    min_value: 0.5
    max_value: 10
    step: 0.5
    optimistic: true
    initial_value: 3

  - platform: template
    id: bypass_close_dt
    name: "Bypass Close Delta T"
    min_value: 1
    max_value: 15
    step: 0.5
    optimistic: true
    initial_value: 5
