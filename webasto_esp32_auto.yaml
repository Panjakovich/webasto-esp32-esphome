substitutions:
  # Пины силовых цепей
  pin_glow_plug: GPIO14        # Свеча накала (PWM)
  pin_fan: GPIO27              # Вентилятор (PWM)
  pin_fuel_pump: GPIO26        # Топливный насос
  pin_water_pump: GPIO25       # Водяная помпа (PWM)
  pin_ntc_sensor: GPIO34       # Датчик температуры Webasto (ADC)
  pin_flame_sensor: GPIO35     # Датчик пламени/тока (ADC)
  pin_dallas: GPIO33           # Шина DS18B20
  pin_bypass: GPIO23           # Клапан байпаса (on/off)

  # Пороговые значения
  overheat_temp_c: "92.0"          # Перегрев Webasto (NTC)
  ignition_timeout_ms: "180000"    # Таймаут розжига (3 мин)
  min_temp_rise_c: "2.0"           # Мин. рост температуры за таймаут

  flame_loss_threshold_v: "2.2"    # Потеря пламени по току
  flame_present_threshold_v: "1.7" # Порог "появилось пламя"

  max_ignite_fail: "3"             # Макс. число неудачных запусков

  # Цель по радиаторной подаче
  radiator_target_c: "50.0"        # Желательная температура подачи на батареи
  radiator_low_c: "45.0"
  radiator_high_c: "55.0"

esphome:
  name: webasto-esp32
  friendly_name: Webasto ESP32 Controller

esp32:
  board: esp32dev
  framework:
    type: arduino
    version: recommended

api:
  encryption:
    key: !secret webasto_api_key
  reboot_timeout: 0s

ota:
  - platform: esphome
    password: !secret webasto_ota_password

safe_mode:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "webasto-esp32-setup"
    password: "12345678"
    ap_timeout: 5s

web_server:
  local: true

logger:
  level: DEBUG

# --- Глобальные переменные ---
globals:
  - id: heater_state
    type: int
    initial_value: '0'   # 0:OFF, 1:PREHEAT, 2:IGNITION, 3:RUNNING, 4:COOLING, 5:ERROR
  - id: fuel_freq
    type: float
    initial_value: '1.2'
  - id: fan_speed
    type: float
    initial_value: '0.3'
  - id: ignite_fail_count
    type: int
    initial_value: '0'
  - id: temp_at_start
    type: float
    initial_value: '0.0'
  - id: ignition_start_time
    type: uint32
    initial_value: '0'
  - id: bench_mode
    type: bool
    initial_value: 'false'
  - id: low_power_start_time
    type: uint32
    initial_value: '0'

# --- Выходы ---
output:
  - platform: ledc
    pin: ${pin_glow_plug}
    id: glow_plug_pwm
    frequency: 500Hz

  - platform: ledc
    pin: ${pin_fan}
    id: fan_pwm
    frequency: 20000Hz

  - platform: gpio
    pin: ${pin_fuel_pump}
    id: fuel_pump_output

  - platform: ledc
    pin: ${pin_water_pump}
    id: coolant_pump_pwm
    frequency: 500Hz

# --- Переключатели ---
switch:
  # Главный выключатель Webasto (HA)
  - platform: template
    name: "Webasto Master Switch"
    id: heater_switch
    icon: "mdi:fire"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

    turn_on_action:
      - if:
          condition:
            lambda: |-
              if (id(heater_state) == 5) return false;
              if (id(ignite_fail_count) >= ${max_ignite_fail}) return false;
              return true;
          then:
            - script.execute: start_sequence
          else:
            - logger.log:
                level: ERROR
                format: "START BLOCKED: error state or too many failed ignitions"
            - switch.turn_off: heater_switch

    turn_off_action:
      - script.execute: stop_sequence

  # Bench Mode для стендовых тестов
  - platform: template
    name: "Webasto Bench Mode"
    id: bench_mode_switch
    icon: "mdi:tools"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: 'id(bench_mode) = true;'
      - logger.log: "Bench mode ENABLED (temperature safety relaxed for tests)."
    turn_off_action:
      - lambda: 'id(bench_mode) = false;'
      - logger.log: "Bench mode DISABLED (temperature safety active)."

  # Сброс ошибки и счётчика неудачных пусков
  - platform: template
    name: "Webasto Reset Error"
    id: heater_reset_switch
    icon: "mdi:restart-alert"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(heater_state) = 0;
          id(ignite_fail_count) = 0;
      - delay: 500ms
      - switch.turn_off: heater_reset_switch

  # Клапан байпаса подача↔обратка
  - platform: gpio
    name: "Bypass Valve"
    id: bypass_valve
    pin: ${pin_bypass}
    restore_mode: RESTORE_DEFAULT_OFF
    icon: "mdi:valve"

# --- Dallas (DS18B20) ---
dallas:
  - pin: ${pin_dallas}
    update_interval: 5s
    id: dallas_bus

# --- Датчики ---
sensor:
  # NTC Webasto (через ADC)
  - platform: adc
    id: water_temp_adc
    pin: ${pin_ntc_sensor}
    attenuation: 12db
    update_interval: 1s

  - platform: template
    id: water_temp_test
    name: "Water Temperature Test"
    unit_of_measurement: "V"
    lambda: |-
      return id(water_temp_adc).state;

  - platform: template
    id: water_temp_resistance
    lambda: |-
      float v_out = id(water_temp_adc).state;
      if (v_out >= 3.25 || v_out <= 0.05) return NAN;
      return 10000.0f * (v_out / (3.3f - v_out));

  - platform: ntc
    id: water_temp
    sensor: water_temp_resistance
    calibration:
      b_constant: 3950
      reference_resistance: 10kOhm
      reference_temperature: 25°C
    name: "Water Temperature"
    on_value_range:
      - above: ${overheat_temp_c}
        then:
          - logger.log:
              level: ERROR
              format: "OVERHEAT DETECTED by NTC!"
          - script.execute: emergency_shutdown

  # Ток свечи / "пламя"
  - platform: adc
    pin: ${pin_flame_sensor}
    id: flame_current
    name: "Glow Plug Current"
    attenuation: 12db
    update_interval: 0.5s
    filters:
      - sliding_window_moving_average:
          window_size: 15
          send_every: 1

  # DS18B20 – подача к радиаторам
  - platform: dallas
    address: 0x0102030405060708   # ЗАМЕНИТЬ на реальный адрес
    name: "Flow Temperature"
    id: flow_temp
    accuracy_decimals: 1

  # DS18B20 – обратка от радиаторов
  - platform: dallas
    address: 0x0807060504030201   # ЗАМЕНИТЬ на реальный адрес
    name: "Return Temperature"
    id: return_temp
    accuracy_decimals: 1

  # ΔT по контуру отопления
  - platform: template
    name: "Delta T Flow-Return"
    id: delta_t
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    update_interval: 5s
    lambda: |-
      if (std::isnan(id(flow_temp).state) || std::isnan(id(return_temp).state)) {
        return NAN;
      }
      return id(flow_temp).state - id(return_temp).state;

  # Текущая скорость вентилятора (в %)
  - platform: template
    name: "Current Fan Speed"
    unit_of_measurement: "%"
    update_interval: 1s
    accuracy_decimals: 1
    lambda: |-
      return id(fan_speed) * 100.0f;

  # Код состояния
  - platform: template
    name: "Heater State Code"
    icon: "mdi:state-machine"
    update_interval: 1s
    accuracy_decimals: 0
    lambda: |-
      return id(heater_state);

  # Частота насоса
  - platform: template
    name: "Fuel Frequency"
    unit_of_measurement: "Hz"
    update_interval: 1s
    lambda: |-
      if (id(heater_state) == 2 || id(heater_state) == 3) {
        return id(fuel_freq);
      } else {
        return 0.0f;
      }

  # Счётчик неудачных розжигов
  - platform: template
    name: "Ignite Fail Count"
    icon: "mdi:alert-counter"
    update_interval: 5s
    accuracy_decimals: 0
    lambda: |-
      return id(ignite_fail_count);

# --- Интервал 50мс: защита, насос, пламя, рост температуры ---
interval:
  - interval: 50ms
    then:
      - lambda: |-
          // 1. Защита по температуре Webasto (NTC)
          float t = id(water_temp).state;

          if (!id(bench_mode)) {
            if (!std::isnan(t) && t > ${overheat_temp_c}) {
              if (id(heater_state) != 0 && id(heater_state) != 4 && id(heater_state) != 5) {
                ESP_LOGE("safety", "OVERHEAT! Temp: %.1f", t);
                id(heater_switch).turn_off();
                id(heater_state) = 5;
              }
            }
          }

          // Ошибка датчика температуры во время розжига/работы
          if (std::isnan(t) && (id(heater_state) == 2 || id(heater_state) == 3)) {
            ESP_LOGE("safety", "TEMP SENSOR ERROR (NaN) during run!");
            id(heater_switch).turn_off();
            id(heater_state) = 5;
          }

          // 2. Управление щелчками топливного насоса
          static uint32_t last_pump = 0;
          static bool pump_is_on = false;

          if (id(heater_state) == 2 || id(heater_state) == 3) {
            uint32_t now = millis();
            if (id(fuel_freq) > 0.01f && now - last_pump >= (uint32_t)(1000.0f / id(fuel_freq))) {
              id(fuel_pump_output).turn_on();
              last_pump = now;
              pump_is_on = true;
            }
          }

          if (pump_is_on && (millis() - last_pump >= 50)) {
            id(fuel_pump_output).turn_off();
            pump_is_on = false;
          }

          // 3. Контроль срыва пламени в RUNNING
          if (id(heater_state) == 3) {
            static int flame_loss_ticks = 0;
            if (id(flame_current).state > ${flame_loss_threshold_v}) {
              flame_loss_ticks++;
              if (flame_loss_ticks > 20) {
                 ESP_LOGW("safety", "FLAME LOSS DETECTED!");
                 id(heater_switch).turn_off();
                 id(heater_state) = 5;
                 flame_loss_ticks = 0;
              }
            } else {
              flame_loss_ticks = 0;
            }
          }

          // 4. Контроль роста температуры Webasto за время розжига/работы
          if (id(heater_state) == 2 || id(heater_state) == 3) {
            uint32_t work_time = millis() - id(ignition_start_time);

            if (work_time > ${ignition_timeout_ms}) {
              if (!std::isnan(t) && !std::isnan(id(temp_at_start))) {
                float temp_diff = t - id(temp_at_start);
                if (temp_diff < ${min_temp_rise_c}) {
                  ESP_LOGE("safety", "IGNITION TIMEOUT: No temp rise! (Diff: %.1f°C)", temp_diff);
                  id(heater_switch).turn_off();
                  id(heater_state) = 5;
                }
              } else {
                ESP_LOGE("safety", "IGNITION TIMEOUT: temp sensor invalid!");
                id(heater_switch).turn_off();
                id(heater_state) = 5;
              }
            }
          } else {
            id(temp_at_start) = 0;
          }

  # Интервал 10с: авто-мощность, клапан байпаса и температура радиаторов
  - interval: 10s
    then:
      - lambda: |-
          float f = id(flow_temp).state;
          float r = id(return_temp).state;
          float d = id(delta_t).state;

          // Управление байпасом и мощностью только когда Webasto реально работает
          if (id(heater_state) == 1 || id(heater_state) == 2) {
            // На преднагреве и розжиге держим байпас открытым — маленький контур,
            // Webasto быстрее выходит на рабочую температуру.
            id(bypass_valve).turn_on();
          } else if (id(heater_state) == 3) {
            // RUNNING: логика по нагрузке и температуре радиаторов
            if (std::isnan(f) || std::isnan(r) || std::isnan(d)) {
              ESP_LOGW("auto_power", "Flow/return/delta_t NAN, skip auto control.");
            } else {
              std::string cur_mode = id(target_power_select).state;
              std::string new_mode = cur_mode;

              // 1. Цель: радиаторная подача около 50°C
              //   - если f < 45°C или d > 8°C -> много тепла забирают -> High
              if (f < ${radiator_low_c} || d > 8.0f) {
                new_mode = "High";
              }
              //   - если 45–55°C и ΔT средний -> Medium
              else if (f >= ${radiator_low_c} && f <= ${radiator_high_c} && d >= 3.0f && d <= 8.0f) {
                new_mode = "Medium";
              }
              //   - если f > 55°C и ΔT маленький -> Low (малая нагрузка, не перегревать контур)
              else if (f > ${radiator_high_c} && d < 3.0f) {
                new_mode = "Low";
              }
              else {
                // По умолчанию стремимся к Medium
                new_mode = "Medium";
              }

              // 2. Защита от сажи: не сидим в Low бесконечно
              if (cur_mode == "Low") {
                uint32_t now = millis();
                if (now - id(low_power_start_time) > 15UL * 60UL * 1000UL) {
                  ESP_LOGI("auto_power", "Long Low power -> bump to Medium for soot prevention");
                  new_mode = "Medium";
                  id(low_power_start_time) = now;
                }
              }

              // 3. Применяем новый режим, если он изменился
              if (new_mode != cur_mode) {
                ESP_LOGI("auto_power", "Auto power: %s -> %s (flow=%.1f, return=%.1f, dT=%.1f)",
                         cur_mode.c_str(), new_mode.c_str(), f, r, d);
                id(target_power_select).publish_state(new_mode);
              }

              // 4. Управление байпасом в RUNNING:
              //   - если нагрузка мала (d < 3) и f < 60°C -> держим байпас открыт, чтобы
              //     часть потока шла в короткий контур и Webasto не остывала слишком
              if (d < 3.0f && f < 60.0f) {
                id(bypass_valve).turn_on();
              }
              //   - если нагрузка большая (d > 5 или f > 65°C) -> закрываем байпас,
              //     гоним тепло в основной контур
              else if (d > 5.0f || f > 65.0f) {
                id(bypass_valve).turn_off();
              }
              //   - иначе оставляем текущее состояние
            }
          } else {
            // Webasto не в работе -> байпас закрыт
            id(bypass_valve).turn_off();
          }

# --- Скрипты управления ---
script:
  - id: start_sequence
    mode: restart
    then:
      - logger.log: "WEB-START: Initializing..."

      # Проверка датчика температуры перед пуском
      - lambda: |-
          if (std::isnan(id(water_temp).state) && !id(bench_mode)) {
            ESP_LOGE("start", "START ABORTED: NTC temp sensor invalid and bench_mode is OFF");
            id(heater_state) = 5;
          }

      - if:
          condition:
            lambda: 'return id(heater_state) == 5;'
          then:
            - logger.log:
                level: ERROR
                format: "WEB-START: Aborted due to ERROR state."
            - switch.turn_off: heater_switch
            - script.stop: start_sequence

      # Включаем помпу на уровне Medium по умолчанию
      - lambda: |-
          id(coolant_pump_pwm).set_level(0.8f);

      - lambda: 'id(heater_state) = 1;'

      # Мягкий старт вентилятора
      - lambda: 'id(fan_speed) = 0.3f;'
      - output.set_level:
          id: fan_pwm
          level: 0.3

      # Свеча накала
      - output.set_level:
          id: glow_plug_pwm
          level: 0.85

      - delay: 45s

      - logger.log: "WEB-START: Ignition phase..."
      - lambda: |-
          id(heater_state) = 2;
          id(temp_at_start) = id(water_temp).state;
          id(ignition_start_time) = millis();

      - delay: 10s

      # Ждём "появления пламени" по токовому датчику
      - wait_until:
          condition:
            lambda: 'return id(flame_current).state < ${flame_present_threshold_v};'
          timeout: 70s

      - if:
          condition:
            lambda: 'return id(flame_current).state < ${flame_present_threshold_v};'
          then:
            - logger.log: "WEB-START: Running mode active"
            - lambda: |-
                id(heater_state) = 3;
                id(ignite_fail_count) = 0;
            - output.set_level:
                id: glow_plug_pwm
                level: 0.0
            - lambda: |-
                id(fan_pwm).set_level(id(fan_speed));
          else:
            - logger.log:
                level: ERROR
                format: "WEB-START: Ignition Failed!"
            - lambda: 'id(ignite_fail_count)++;'
            - script.execute: stop_sequence

  - id: stop_sequence
    mode: restart
    then:
      - logger.log: "WEB-STOP: Cooling cycle..."
      - lambda: 'id(heater_state) = 4;'
      - output.set_level:
          id: glow_plug_pwm
          level: 0.0
      - output.set_level:
          id: fan_pwm
          level: 1.0
      - delay: 150s
      - output.set_level:
          id: fan_pwm
          level: 0.0
      - output.set_level:
          id: coolant_pump_pwm
          level: 0.0
      - lambda: 'id(heater_state) = 0;'
      - logger.log: "WEB-STOP: System Idle"

  - id: emergency_shutdown
    mode: restart
    then:
      - logger.log:
          level: ERROR
          format: "EMERGENCY SHUTDOWN!"
      - lambda: 'id(heater_state) = 5;'
      - output.set_level:
          id: glow_plug_pwm
          level: 0.0
      - output.set_level:
          id: fan_pwm
          level: 1.0
      - delay: 180s
      - output.set_level:
          id: fan_pwm
          level: 0.0
      - output.set_level:
          id: coolant_pump_pwm
          level: 0.0

# --- Текстовый статус ---
text_sensor:
  - platform: template
    name: "Heater Status"
    lambda: |-
      switch (id(heater_state)) {
        case 1: return {"Нагрев свечи"};
        case 2: return {"Розжиг"};
        case 3: return {"Работа"};
        case 4: return {"Охлаждение"};
        case 5: return {"ОШИБКА/ПЕРЕГРЕВ/ДАТЧИК"};
        default: return {"Выключен"};
      }

# --- Выбор мощности ---
select:
  - platform: template
    name: "Target Power"
    id: target_power_select
    options: ["Low", "Medium", "High"]
    initial_option: "Medium"
    optimistic: true
    on_value:
      then:
        - lambda: |-
            if (x == "Low") {
              id(fuel_freq) = 1.2f;
              id(fan_speed) = 0.3f;
              id(low_power_start_time) = millis();
            } else if (x == "Medium") {
              id(fuel_freq) = 2.8f;
              id(fan_speed) = 0.5f;
            } else if (x == "High") {
              id(fuel_freq) = 5.0f;
              id(fan_speed) = 0.9f;
            }

            // Вентилятор
            if (id(heater_state) == 3) {
              id(fan_pwm).set_level(id(fan_speed));
            }

            // PWM помпы в зависимости от мощности
            float pump_level = 1.0f;
            if (x == "Low") {
              pump_level = 0.6f;
            } else if (x == "Medium") {
              pump_level = 0.8f;
            } else { // High
              pump_level = 1.0f;
            }
            id(coolant_pump_pwm).set_level(pump_level);
